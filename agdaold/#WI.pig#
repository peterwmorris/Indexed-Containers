load /home/pwm/darcs/Pig09/test/TaggedInduction.pig ;

data W (S : Set) (P : S -> Set) : Set := ('sup : (s : S) -> (f : P s -> W S P) -> W S P) ;

let WI0 (I : Set) (S : I -> Set) (P : (i : I) -> S i -> I -> Set) : Set ;
refine WI0 I S P = W (Sig (i : I ; S i)) (\ is -> Sig (j : I ; P (is !) (is -) j)) ; 

let WI0lab (I : Set) (S : I -> Set) (P : (i : I) -> S i -> I -> Set) : Set ;
refine WI0lab I S P = W (Sig (Sig (i : I ; S i) ; I)) (\ isi -> Sig (j : I ; P (isi ! !) (isi ! -) j)) ; 

let actual (I : Set) (S : I -> Set) (P : (i : I) -> S i -> I -> Set) (x : WI0 I S P) : WI0lab I S P ;
refine actual I S P x <= W.Ind (Sig (i : I ; S i)) (\ is -> Sig (j : I ; P (is !) (is -) j)) x ;
refine actual I S P ('sup [i , s] f) = 'sup [[i , s] , i] (\ jp -> actual I S P (f jp)) ;

let ideal (I : Set) (S : I -> Set) (P : (i : I) -> S i -> I -> Set) (i : I) (x : WI0 I S P) : WI0lab I S P ;
refine ideal I S P i x <= W.Ind (Sig (i : I ; S i)) (\ is -> Sig (j : I ; P (is !) (is -) j)) x ;
refine ideal I S P ii ('sup [ia , s] f) = 'sup [[ia , s] , ii] (\ jp -> ideal I S P (jp !) (f jp)) ;

let WI1 (I : Set) (S : I -> Set) (P : (i : I) -> S i -> I -> Set) (i : I) (x : WI0 I S P) : Set ;
refine WI1 I S P i x = :- (actual I S P x == ideal I S P i x) ;

let WI(I : Set) (S : I -> Set) (P : (i : I) -> S i -> I -> Set) (i : I) : Set ;
refine WI I S P i = Sig (x : WI0 I S P ; WI1 I S P i x) ; 

let isup0 (I : Set) (S : I -> Set) (P : (i : I) -> S i -> I -> Set) (i : I)
           (s : S i) (f : (j : I) -> P i s j -> WI I S P j) : WI0 I S P ;
refine isup0 I S P i s f = 'sup [ i , s ] (\ jp -> f (jp !) (jp -) !)  ;

let isup1p (I : Set) (S : I -> Set) (P : (i : I) -> S i -> I -> Set) (i : I)
            (s : S i) (f : (j : I) -> P i s j -> WI I S P j) 
             (jp : Sig (j : I ; P i s j)) (kq : Sig (j : I ; P i s j))  
              (p : :- ((jp !) == (kq !))) (q : :- ((jp -) == (kq -)))
           : :- ((actual I S P (f (jp !) (jp -) !)) == (ideal I S P (jp !) (f (kq !) (kq -) !))) ;
root ;

make isup1 : (I : Set) (S : I -> Set) (P : (i : I) -> S i -> I -> Set) (i : I)
              (s : S i) (f : (j : I) -> P i s j -> WI I S P j) ->
               WI1 I S P i (isup0 I S P i s f) ;
simplify ;
give \ jp kq p q -> isup1p I S P i s f jp kq p q ;
give _ ;
give _ ;
root ;

let isup (I : Set) (S : I -> Set) (P : (i : I) -> S i -> I -> Set) (i : I)
          (s : S i) (f : (j : I) -> P i s j -> WI I S P j) : WI I S P i ;
refine isup I S P i s f = [ (isup0 I S P i s f) , isup1 I S P i s f ] ; 

let IWInd (I : Set) (S : I -> Set) (P : (i : I) -> S i -> I -> Set) (i : I)
           (x : WI I S P i) (Q : (i : I) -> WI I S P i -> Set) 
            (misup : (i : I) (s : S i) (f : (j : I) -> P i s j -> WI I S P j)
                      (fh : (j : I) (p : P i s j) -> Q j (f j p)) ->
                       Q (isup I S P i s f)) 
          : Q i x ;



